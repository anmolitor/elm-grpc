module Grpc exposing
    ( Rpc, RpcRequest, new
    , addHeader, addHeaders, setHost, setTimeout, setTracker
    , toTask, toCmd
    , Error(..), GrpcStatus(..)
    )

{-| This is the public API for gRPC application usage. It is intended to be imported qualified.


# Main Types

@docs Rpc, RpcRequest, new


# Configuring the request

@docs addHeader, addHeaders, setHost, setTimeout, setTracker


# Sending the request

@docs toTask, toCmd


# Handling Errors

@docs Error, GrpcStatus

-}

import Bytes exposing (Bytes)
import Bytes.Decode
import Bytes.Encode
import Dict exposing (Dict)
import Grpc.Internal
import Http exposing (Response(..), header)
import Protobuf.Decode exposing (Decoder, decode)
import Protobuf.Encode exposing (encode)
import Task exposing (Task)


{-| Opaque type for an rpc endpoint. These should be constructed by the `protoc-gen-elm` code generator.
If for some reason, you need to define an endpoint by hand, you can do so by importing the `Grpc.Internal` module.
-}
type alias Rpc req res =
    Grpc.Internal.Rpc req res


{-| A request to the server that has not been sent yet. This is designed to be used in a builder-pattern kind of way:

    Grpc.new helloWorld "hello"
        |> Grpc.addHeader "authorization" token
        |> Grpc.setHost "http://example.com"

    In this example `helloWorld` could be a value of type `Rpc String String` that was generated by `protoc-gen-elm`.

-}
type alias RpcRequest req res =
    InternalRpcRequest req res Never


{-| Build a request from an rpc endpoint by providing a request body.
-}
new : Rpc req res -> req -> RpcRequest req res
new rpc req =
    InternalRpcRequest
        { rpc = rpc
        , body = req
        , headers = Dict.empty
        , host = ""
        , tracker = Nothing
        , timeout = Nothing
        }


{-| Add a header to a request. The first parameter is the header name, the second parameter is the value.
-}
addHeader : String -> String -> InternalRpcRequest req res usesTracker -> InternalRpcRequest req res usesTracker
addHeader key value (InternalRpcRequest req) =
    InternalRpcRequest { req | headers = Dict.insert key value req.headers }


{-| Add multiple headers at once to a request.
-}
addHeaders : List ( String, String ) -> InternalRpcRequest req res usesTracker -> InternalRpcRequest req res usesTracker
addHeaders headers (InternalRpcRequest req) =
    InternalRpcRequest { req | headers = List.foldl (\( k, v ) dict -> Dict.insert k v dict) req.headers headers }


{-| Set the host for the request. By default the host is empty (i.e. the current website), which is recommended to avoid CORS issues.
-}
setHost : String -> InternalRpcRequest req res usesTracker -> InternalRpcRequest req res usesTracker
setHost host (InternalRpcRequest req) =
    InternalRpcRequest { req | host = host }


{-| The tracker lets you cancel and track requests via `Http.cancel` and `Http.track`.
This only works if you use `toCmd` to send your Request, Tasks unfortunately do not support this.
We use the type system to our advantage here to prevent you from calling `toTask` after using this function.
-}
setTracker : String -> InternalRpcRequest req res usesTracker -> InternalRpcRequest req res ()
setTracker tracker (InternalRpcRequest req) =
    InternalRpcRequest { req | tracker = Just tracker }


{-| Make the request cancel itself after a given timeout in milliseconds.
-}
setTimeout : Float -> InternalRpcRequest req res usesTracker -> InternalRpcRequest req res usesTracker
setTimeout timeoutInMs (InternalRpcRequest req) =
    InternalRpcRequest { req | timeout = Just timeoutInMs }


{-| Convert the given `RpcRequest` into a Command to make the Elm runtime execute the request.
-}
toCmd : (Result Error res -> msg) -> InternalRpcRequest req res usesTracker -> Cmd msg
toCmd expect (InternalRpcRequest req) =
    let
        (Grpc.Internal.Rpc rpc) =
            req.rpc

        body =
            encode (rpc.encoder req.body)
                |> frameRequest
                |> Http.bytesBody grpcContentType
    in
    Http.request
        { method = "POST"
        , headers = [ header "accept" grpcContentType ]
        , url = rpcToUrl req.rpc
        , body = body
        , timeout = req.timeout
        , expect = Http.expectBytesResponse expect (handleResponse rpc.decoder)
        , tracker = req.tracker
        }


{-| Convert the given `RpcRequest` into a Task. This can be useful if you want to chain multiple requests but are only
interested in the end result.
-}
toTask : RpcRequest req res -> Task Error res
toTask (InternalRpcRequest req) =
    let
        (Grpc.Internal.Rpc rpc) =
            req.rpc

        body =
            encode (rpc.encoder req.body)
                |> frameRequest
                |> Http.bytesBody grpcContentType
    in
    Http.task
        { method = "POST"
        , headers = [ header "accept" grpcContentType ]
        , url = rpcToUrl req.rpc
        , body = body
        , timeout = req.timeout
        , resolver = Http.bytesResolver (handleResponse rpc.decoder)
        }


{-| A gRPC request may fail with in a variety of ways.
Since the request is just a HTTP request under the hood, it may fail in the roughly same ways a HTTP request could.

  - `BadUrl` means you did not provide a valid URL.

  - `Timeout` means it took too long to get a response.

  - `NetworkError` means the user turned off their wifi, went in a cave, etc.

  - `BadStatus` means you got a response back, but the http status code indicates failure. This can be either
    a bad HTTP status code or a bad `grpc-status` response header according to
    <https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md>

  - `BadBody` means you got a response back with a nice status code, but the body
    of the response was something unexpected. The `Bytes` in this case is the response that failed to be parsed.

  - `UnknownGrpcStatus` means you got a response back but the `grpc-status` header was set to either

      - something that is not an `Int`
      - an `Int` that is outside of the range of the `ErrCode` enum.

    Note that not setting the header is fine and will delegate failure checking to the HTTP status.

-}
type Error
    = BadUrl String
    | Timeout
    | NetworkError
    | BadStatus { metadata : Http.Metadata, response : Bytes, errMessage : String, status : GrpcStatus }
    | BadBody Bytes
    | UnknownGrpcStatus String


{-| A valid `grpc-status` header encodes one of these possibilities as an Int.

  - `0` -> Ok\_
  - `1` -> Cancelled
  - `2` -> Unknown
  - ...

-}
type GrpcStatus
    = Ok_
    | -- The operation was cancelled.
      Cancelled
    | -- Unknown error.
      Unknown
    | -- Client specified an invalid argument.
      InvalidArgument
    | -- Deadline expired before operation could complete.
      DeadlineExceeded
    | -- Some requested entity was not found.
      NotFound
    | -- Some entity that we attempted to create already exists.
      AlreadyExists
    | -- The caller does not have permission to execute the specified operation.
      PermissionDenied
    | -- Some resource has been exhausted.
      ResourceExhausted
    | -- The system is not in a state required for the operation's execution.
      FailedPrecondition
    | -- The operation was aborted.
      Aborted
    | -- Operation was attempted past the valid range.
      OutOfRange
    | -- Operation is not implemented or not supported.
      Unimplemented
    | -- Internal error.
      Internal
    | -- The service is currently unavailable.
      Unavailable
    | -- Unrecoverable data loss or corruption.
      DataLoss
    | -- The request does not have valid authentication credentials
      Unauthenticated



-- INTERNALS


type InternalRpcRequest req res usesTracker
    = InternalRpcRequest
        { rpc : Rpc req res
        , body : req
        , headers : Dict String String
        , host : String
        , tracker : Maybe String
        , timeout : Maybe Float
        }


grpcContentType : String
grpcContentType =
    "application/grpc-web+proto"


rpcToUrl : Rpc req res -> String
rpcToUrl (Grpc.Internal.Rpc { service, package, rpcName }) =
    "/"
        ++ (if String.isEmpty package then
                ""

            else
                package ++ "."
           )
        ++ service
        ++ "/"
        ++ rpcName


handleResponse : Decoder res -> Http.Response Bytes -> Result Error res
handleResponse decoder httpResponse =
    let
        parseResponse : Bool -> Http.Metadata -> Bytes -> Result Error res
        parseResponse isGoodStatus metadata bytes =
            let
                defaultGrpcStatus =
                    if isGoodStatus then
                        Ok_

                    else
                        httpBadStatusToGrpcStatus metadata.statusCode

                grpcStatus =
                    Dict.get "grpc-status" metadata.headers
                        |> Maybe.andThen String.toInt
                        |> Maybe.andThen errCodeFromInt
                        |> Maybe.withDefault defaultGrpcStatus
            in
            case grpcStatus of
                Ok_ ->
                    Bytes.Decode.decode responseDecoder bytes
                        |> Maybe.andThen (\response -> decode decoder response.message)
                        |> Result.fromMaybe (BadBody bytes)

                _ ->
                    let
                        errMessage =
                            Dict.get "grpc-message" metadata.headers
                                |> Maybe.withDefault metadata.statusText
                    in
                    Err <| BadStatus { status = grpcStatus, errMessage = errMessage, metadata = metadata, response = bytes }
    in
    case httpResponse of
        GoodStatus_ metadata bytes ->
            parseResponse True metadata bytes

        BadUrl_ badUrl ->
            Err <| BadUrl badUrl

        Timeout_ ->
            Err Timeout

        NetworkError_ ->
            Err NetworkError

        BadStatus_ metadata bytes ->
            parseResponse False metadata bytes


{-| Mapping is implemented according to <https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md>
-}
httpBadStatusToGrpcStatus : Int -> GrpcStatus
httpBadStatusToGrpcStatus statusCode =
    case statusCode of
        400 ->
            Internal

        401 ->
            Unauthenticated

        403 ->
            PermissionDenied

        404 ->
            Unimplemented

        429 ->
            Unavailable

        502 ->
            Unavailable

        503 ->
            Unavailable

        504 ->
            Unavailable

        _ ->
            Unknown


requestEncoder : Bytes -> Bytes.Encode.Encoder
requestEncoder message =
    let
        messageLength =
            Bytes.width message
    in
    Bytes.Encode.sequence
        [ Bytes.Encode.unsignedInt8 0
        , Bytes.Encode.unsignedInt32 Bytes.BE messageLength
        , Bytes.Encode.bytes message
        ]


type alias Response =
    { message : Bytes
    }


responseDecoder : Bytes.Decode.Decoder Response
responseDecoder =
    Bytes.Decode.map2 (\_ -> Response)
        (Bytes.Decode.bytes 1)
        (Bytes.Decode.unsignedInt32 Bytes.BE
            |> Bytes.Decode.andThen Bytes.Decode.bytes
        )


frameRequest : Bytes -> Bytes
frameRequest binaryData =
    requestEncoder binaryData
        |> Bytes.Encode.encode


errCodeFromInt : Int -> Maybe GrpcStatus
errCodeFromInt n =
    case n of
        0 ->
            Just Ok_

        1 ->
            Just Cancelled

        2 ->
            Just Unknown

        3 ->
            Just InvalidArgument

        4 ->
            Just DeadlineExceeded

        5 ->
            Just NotFound

        6 ->
            Just AlreadyExists

        7 ->
            Just PermissionDenied

        8 ->
            Just ResourceExhausted

        9 ->
            Just FailedPrecondition

        10 ->
            Just Aborted

        11 ->
            Just OutOfRange

        12 ->
            Just Unimplemented

        13 ->
            Just Internal

        14 ->
            Just Unavailable

        15 ->
            Just DataLoss

        16 ->
            Just Unauthenticated

        _ ->
            Nothing
